---
title: "CVE-2024-0517 Chrome V8 Out of Bounds Write"
excerpt: "A deep dive about CVE-2024-0517"

categories: blog
tags: 1-day chrome v8

toc: true
toc_sticky: true
---

<br>
# Introduction
In this blog, we look into a vulnerability in Chrome V8, CVE-2024-0517. This vulnerability occurs when Maglev, the JIT compiler of V8, compiles a class that has a parent class. <br>
Since I'm a beginner in the cybersecurity field and this is my first time analyzing a 1-day exploit, I had a lot of difficulty understanding it. Therefore, I'll explain this vulnerability step by step. <br>

<br>
# Environment Configuration
The version that I used is as follows:
[chrome v8 12.0.267.15](https://chromium.googlesource.com/v8/v8.git/+/e73f620c2ef1230ddaa61551706225821a87c3b9){: target="_blank"} <br>

```javascript
# install depot_tools
cd ~
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
export PATH=$HOME/depot_tools:$PATH
echo 'export PATH=$HOME/depot_tools:$PATH' >> ~/.zshrc

# get V8
cd ~
fetch v8
cd v8
git checkout e73f620c2ef1230ddaa61551706225821a87c3b9
gclient sync -D

# build V8
./build/install-build-deps.sh
gn gen out/debug --args='v8_no_inline=true v8_optimized_debug=false is_component_build=false v8_expose_memory_corruption_api=true'
ninja -C out/debug d8
./tools/dev/gm.py x64.release

# install gdb plugin
echo 'source ~/v8/tools/gdbinit' >> ~/.gdbinit
```

<br>
# Preliminary Knowledge
In this section I'll explain some essential preliminary knowledges needed to understand vulnerability. <br>
The first three points are very important, and the remaining content helps in understanding the entire vulnerability by being aware of the memory structure. <br>

## V8 engine
<center> <img src="https://www.fhinkel.rocks/assets/blog/Understanding-V8-s-Bytecode/img2.png" width="70%" height="70%" title="git_diff"/> </center>
<center> <img src="https://www.phoronix.net/image.php?id=2023&image=maglev" width="70%" height="70%" title="git_diff"/> </center>
V8 is composed of various components such as Ignition, Maglev. I organized some features about them.
* Parser    : converts Javascript code to AST structure
* Ignition  : coverts AST structure to bytecode directly when code executes
* Sparkplug : compile and optimize bytecode without any analysis
* Maglev    : compile and optimize bytecode with static analysis
* Turbofan  : compile and optimize bytecode with dynamic analysis
The purpose of optimizing code is to ensure that subsequent executions are faster because the generated code will be reused in future calls.

In the Vulnerability Exploitation Flow section, I'll outline the process leading to the weak point. 

## Allocation Folding
<center> <img src="https://github.com/user-attachments/assets/d8b42923-9971-43b3-9744-079a47909f5a" title="allocation_folding"/> </center>
Allocation Folding is a technique that improves performance and reduces memory overhead. It folds multiple allocation to a single one, so next allocation will be positioned with the offset by first allocation(AllocateRaw node). For example, if there are two allocations with amounts of 12 bytes and 88 bytes, Maglev folds them to one allocation with 100 bytes and the second allocation will be allocated on FirstAllocate_addr+12 (because the first requests 12 bytes).

## Garbage Collection
<center> <img src="https://github.com/user-attachments/assets/0013d02f-cd2b-4474-aa0f-887ec73991b1" title="v8_heap_structure"/> </center> <br> 
Garbage Collection is a memory management process that frees object without any reference. <br>
In v8 there are two Garbage collector, minor GC and major GC. If semi-space(from-space) is filled fully, minor GC runs and frees needless object. Conversely, it is applied in the same way. And if an object survives after running twice of garbage collection, it will be moved into old space. <br> 

I recommend to read this blog that is perfect to learn about garbage collection.
<https://deepu.tech/memory-management-in-v8/>{: target="_blank"}

<br>
# The Vulnerability
When V8 compiles a derived class, the current_raw_allocation pointer is not initialized, leading to unintended memory allocation and potentially causing an out-of-bounds(OOB) write. <br>
The above content means that v8 calls VisitFindNonDefaultConstructorOrConstruct function. About this function I'll explain in Vulnerability Exploitation Flow section. <br>
<br>
The Proof of Concept code is on [here](https://github.com/bnovkebin/bnovkebin.github.io/blob/5f951163790653ce1426d0ac8427a8b170c22ca7/_posts/2024/20240814/poc.js){: target="_blank"}
<br>
If you run this code, it results : 
```cpp
$ ~/v8/out$ ./debug/d8 --max-opt=2 --allow-natives-syntax --expose-gc --jit-fuzzing ./code0810/poc.js

#
# Fatal error in ../../src/objects/free-space-inl.h, line 75
# Check failed: !heap->deserialization_complete() || map_slot().contains_map_value(free_space_map.ptr()).
#
#
#
#FailureMessage Object: 0x7ffcb71ef328
==== C stack trace ===============================

    ./debug/d8(v8::base::debug::StackTrace::StackTrace()+0x1e) [0x5be5e179afde]
    ./debug/d8(+0x8c0960d) [0x5be5e179560d]
    ./debug/d8(V8_Fatal(char const*, int, char const*, ...)+0x1ac) [0x5be5e176b53c]
    ./debug/d8(v8::internal::FreeSpace::IsValid() const+0xdf) [0x5be5dde6ceef]
    ./debug/d8(v8::internal::FreeSpace::next() const+0x1d) [0x5be5dde6baad]
```
<br>
If you want :
* Debugging => `./debug/d8 (option) ./code/poc.js`
* Release   => `./x64.release/d8 (option) ./code/poc.js`

I frequently use options like :
* `--allow-natives-syntax` => allow using debugging symbol
* `--print-maglev-graph` => show maglev-IR-graph that maglev has compiled

(other options : `--max-opt=2 --expose-gc --jit-fuzzing`) <br>

If you set a breakpoint before allocate array a and after that, you can see the memory corrupt by allocation folding of array a. <br>
<center> <img src="https://github.com/user-attachments/assets/574d05eb-ab29-4ed3-ac49-9cdc5b70041e" /> </center>

## ExtendOrReallocateCurrentRawAllocation
This function represents methods to do allocation folding with **"current_raw_allocation"** pointer.

```cpp
/* src/maglev/maglev-graph-builder.cc:8520 */
ValueNode* MaglevGraphBuilder::ExtendOrReallocateCurrentRawAllocation(
    int size, AllocationType allocation_type) {
  if (!current_raw_allocation_ ||
      current_raw_allocation_->allocation_type() != allocation_type ||
      !v8_flags.inline_new) {
    current_raw_allocation_ =
        AddNewNode<AllocateRaw>({}, allocation_type, size);
    return current_raw_allocation_;
  }
  int current_size = current_raw_allocation_->size();
  if (current_size + size > kMaxRegularHeapObjectSize) {
    return current_raw_allocation_ =
               AddNewNode<AllocateRaw>({}, allocation_type, size);
  }
  DCHECK_GT(current_size, 0);
  int previous_end = current_size;
  current_raw_allocation_->extend(size);
  return AddNewNode<FoldedAllocation>({current_raw_allocation_}, previous_end);
}
```

## Patch
To prevent this weakness, initialization of that pointer has been added to the source code.
This vulnerability was patched in version 12.0.267.16. You can verify this using **"git diff"**. <br>

`git diff fbc4963bbff79ae2ef36821f870295f488cb497b e73f620c2ef1230ddaa61551706225821a87c3b9` <br>

<center> <img src="https://github.com/user-attachments/assets/61e0a27d-596c-49a7-82d8-e66a0c17f294" title="git_diff"/> </center>

<br>
# Vulnerability Exploitation Flow
To understand about vulnerability it will help that draw a flow. <br><br>
The Exploitation flow is : <br>
1) Execute javascript code on V8 engine <br> 
2) V8 convert source code to AST structure. In this part, Parser converts **super();** function as a call node with **Super type**. <br> 
<center> <img src="https://github.com/user-attachments/assets/a807549d-360c-491d-9350-2f5e5da0ba16" title="parser" width="40%" height="40%"/> </center>
<br>
3) Ignition calls **"VisitCall"** function when interpretes a call node. And as this node has super type, in the end Ignition makes an **"FindNonDefaultConstructorOrContruct"** instruction. <br>
<center> <img src="https://github.com/user-attachments/assets/06f5c201-32b8-485b-aab6-26190171e23a" width="50%" height="50%" /> </center>
<br>
4) Since this source code is marked as "hot" code, Maglev starts to optimize and compile. Maglev puts a word "Visit" in front of instruction, and calls function in Maglev's source code(i.e. VisitFindNonDefaultConstructorOrConstruct). <br>
<center> <img src="https://github.com/user-attachments/assets/670fdaa4-b171-4c2f-827c-1d620628d594" width="45%" height="45%" /> </center>
<br>
5) When Maglev builds an allocation of object, there is no initialization of **"current_raw_allocation"** pointer. That is a root cause of this vulnerability. <br>
<center> <img src="https://github.com/user-attachments/assets/81ca884a-f1cf-4436-a073-6c936075a8f8" width="60%" height="60%" /> </center>
<br>
6) As seen at poc code, we will make a garbage collection with "[1]=dogc();" after allocation of x array, all alived objects are moved into old space. <br>
7) Now it is turn to allocate a array. Given that the position to allocate x array has already decided with **"this object + offset"**, a array will be allocated in unintended address of memory (OOB Write). <br>
<center> <img src="https://github.com/user-attachments/assets/c176f0c2-0fa2-4157-b634-771272130dad" width="50%" height="50%" /> </center>

<br>
# Exploitation
<center> <img src="https://github.com/user-attachments/assets/61a32f48-8f3c-408c-8e2b-b26f514b7a91" /> </center>
Using an OOB wirte, we could make a type confusion between two objects(x array & a array) with different types. <br>
The first one has a PACKED_ELEMENTS type. And the other one has a PACKED_DOUBLE_ELEMENTS type. <br>
An array object that has PACKED_ELEMENTS stores Object or Integer. <br>
Same thing with PACKED_DOUBLE_ELEMENTS stores Float value. <br>
We know that their elements have same address in heap. Furthermore an overlapped memory is read differently. If we store an object at x[0], x array reads that memory as an object. However a array reads as a float value, that means we could leak the address of stored object.<br>
<center> <img src="https://github.com/user-attachments/assets/483980ba-1f87-4d1d-886a-539d3b201ee3" /> </center>

## Triggering the Vulnarability
I used the code on exodus blog. For the reason that doesn't trigger well the vulnerability, I tried to change number of times and size of array for garbage collection. <br>
After triggered vulnerability, memory structure in our environment is same with [this](https://github.com/user-attachments/assets/61a32f48-8f3c-408c-8e2b-b26f514b7a91) that I uploaded on Exploitation. <br>

## Exploit primitives
Now we made an OOB write in heap, using that we will implement some primitives that lead to exploit. <br>
Before analyzing the full-exploit code is [here](https://github.com/bnovkebin/bnovkebin.github.io/blob/5f951163790653ce1426d0ac8427a8b170c22ca7/_posts/2024/20240814/exploit.js){: target="_blank"} <br>




<br>
### addrof

### write

## Bypass ubercage with WebAssembly
8. WebAssembly <br>

### Shellcode Smuggling

### RIP control

### Running Shellcode
9. exploit 시연 <br>

# Conclusion
10. 내가 이 글을 쓰는 목표한 바, 어떤 취약점이였는지 총정리 <br>

# Preferences




