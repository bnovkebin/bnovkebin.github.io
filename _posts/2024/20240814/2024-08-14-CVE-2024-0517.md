---
title: "CVE-2024-0517 Chrome V8 Out of Bounds Write"
excerpt: "A deep dive about CVE-2024-0517"

categories: blog
tags: 1-day chrome v8

toc: true
toc_sticky: true
---

<br>
# Introduction
In this blog, we look into a vulnerability in Chrome V8, CVE-2024-0517. This vulnerability occurs when Maglev, the JIT compiler of V8, compiles a class that has a parent class. <br>
Since I'm a beginner in the cybersecurity field and this is my first time analyzing a 1-day exploit, I had a lot of difficulty understanding it. Therefore, I'll explain this vulnerability step by step. <br>

<br>
# Environment Configuration
The version that I used is as follows:
[chrome v8 12.0.267.15](https://chromium.googlesource.com/v8/v8.git/+/e73f620c2ef1230ddaa61551706225821a87c3b9) <br>

```javascript
# install depot_tools
cd ~
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
export PATH=$HOME/depot_tools:$PATH
echo 'export PATH=$HOME/depot_tools:$PATH' >> ~/.zshrc

# get V8
cd ~
fetch v8
cd v8
git checkout e73f620c2ef1230ddaa61551706225821a87c3b9
gclient sync -D

# build V8
./build/install-build-deps.sh
gn gen out/debug --args='v8_no_inline=true v8_optimized_debug=false is_component_build=false v8_expose_memory_corruption_api=true'
ninja -C out/debug d8
./tools/dev/gm.py x64.release

# install gdb plugin
echo 'source ~/v8/tools/gdbinit' >> ~/.gdbinit
```

<br>
# Preliminary Knowledge
In this section I'll explain some essential preliminary knowledges needed to understand vulnerability. <br>
The first three points are very important, and the remaining content helps in understanding the entire vulnerability by being aware of the memory structure. <br>

## V8 engine
<center> <img src="https://www.fhinkel.rocks/assets/blog/Understanding-V8-s-Bytecode/img2.png" width="70%" height="70%" title="git_diff"/> </center>
<center> <img src="https://www.phoronix.net/image.php?id=2023&image=maglev" width="70%" height="70%" title="git_diff"/> </center>
V8 is composed of various components such as Ignition, Maglev. I organized some features about them.
* Parser    : converts Javascript code to AST structure
* Ignition  : coverts AST structure to bytecode directly when code executes
* Sparkplug : compile and optimize bytecode without any analysis
* Maglev    : compile and optimize bytecode with static analysis
* Turbofan  : compile and optimize bytecode with dynamic analysis
The purpose of optimizing code is to ensure that subsequent executions are faster because the generated code will be reused in future calls.

In the [Vulnerability Exploitation Flow section](#Vulnerability-Exploitation-Flow), I'll outline the process leading to the weak point. 

## Allocation Folding
<center> <img src="https://github.com/user-attachments/assets/d8b42923-9971-43b3-9744-079a47909f5a" title="allocation_folding"/> </center>
Allocation Folding is a technique that improves performance and reduces memory overhead. It folds multiple allocation to a single one, so next allocation will be positioned with the offset by first allocation(AllocateRaw node). For example, if there are two allocations with amounts of 12 bytes and 88 bytes, Maglev folds them to one allocation with 100 bytes and the second allocation will be allocated on FirstAllocate_addr+12 (because the first requests 12 bytes).

## Garbage Collection
<center> <img src="https://github.com/user-attachments/assets/0013d02f-cd2b-4474-aa0f-887ec73991b1" title="v8_heap_structure"/> </center> <br> 
Garbage Collection is a memory management process that frees object without any reference. <br>
In v8 there are two Garbage collector, minor GC and major GC. If semi-space(from-space) is filled fully, minor GC runs and frees needless object. Conversely, it is applied in the same way. And if an object survives after running twice of garbage collection, it will be moved into old space. <br> 

I recommend to read this blog that is perfect to learn about garbage collection.
<https://deepu.tech/memory-management-in-v8/>

<br>
# The Vulnerability
When V8 compiles a derived class, the current_raw_allocation pointer is not initialized, leading to unintended memory allocation and potentially causing an out-of-bounds(OOB) write. <br>
The above content means that v8 calls VisitFindNonDefaultConstructorOrConstruct function. <br>
<br>
The Proof of Concept code is on [here]()
<br>
If you run this code, it results : 
```cpp
$ ~/v8/out$ ./debug/d8 --max-opt=2 --allow-natives-syntax --expose-gc --jit-fuzzing ./code0810/poc.js

#
# Fatal error in ../../src/objects/free-space-inl.h, line 75
# Check failed: !heap->deserialization_complete() || map_slot().contains_map_value(free_space_map.ptr()).
#
#
#
#FailureMessage Object: 0x7ffcb71ef328
==== C stack trace ===============================

    ./debug/d8(v8::base::debug::StackTrace::StackTrace()+0x1e) [0x5be5e179afde]
    ./debug/d8(+0x8c0960d) [0x5be5e179560d]
    ./debug/d8(V8_Fatal(char const*, int, char const*, ...)+0x1ac) [0x5be5e176b53c]
    ./debug/d8(v8::internal::FreeSpace::IsValid() const+0xdf) [0x5be5dde6ceef]
    ./debug/d8(v8::internal::FreeSpace::next() const+0x1d) [0x5be5dde6baad]
```
<br>
If you want :
* Debugging => ./debug/d8 (option) ./code/poc.js
* Release   => ./x64.release/d8 (option) ./code/poc.js

I frequently use options like :
* --allow-natives-syntax => allow using debugging symbol
* --print-maglev-graph => show maglev-IR-graph that maglev has compiled

(other options : --max-opt=2 --expose-gc --jit-fuzzing) <br>

If you set a breakpoint before allocate array a and after that, you can see the memory corrupt by allocation folding of array a. <br>


## ExtendOrReallocateCurrentRawAllocation
This function represents methods to do allocation folding with **"current_raw_allocation"** pointer.

```cpp
/* src/maglev/maglev-graph-builder.cc:8520 */
ValueNode* MaglevGraphBuilder::ExtendOrReallocateCurrentRawAllocation(
    int size, AllocationType allocation_type) {
  if (!current_raw_allocation_ ||
      current_raw_allocation_->allocation_type() != allocation_type ||
      !v8_flags.inline_new) {
    current_raw_allocation_ =
        AddNewNode<AllocateRaw>({}, allocation_type, size);
    return current_raw_allocation_;
  }
  int current_size = current_raw_allocation_->size();
  if (current_size + size > kMaxRegularHeapObjectSize) {
    return current_raw_allocation_ =
               AddNewNode<AllocateRaw>({}, allocation_type, size);
  }
  DCHECK_GT(current_size, 0);
  int previous_end = current_size;
  current_raw_allocation_->extend(size);
  return AddNewNode<FoldedAllocation>({current_raw_allocation_}, previous_end);
}
```

## Patch
To prevent this weakness, initialization of that pointer has been added to the source code.
This vulnerability was patched in version 12.0.267.16. You can verify this using **"git diff"**. <br>

```linux
git diff fbc4963bbff79ae2ef36821f870295f488cb497b e73f620c2ef1230ddaa61551706225821a87c3b9
```

<center> <img src="https://github.com/user-attachments/assets/61e0a27d-596c-49a7-82d8-e66a0c17f294" title="git_diff"/> </center>


<br>
# Vulnerability Exploitation Flow
5. 취약점 흐름 <br>

# Exploitation
6. exploit 전체 과정 요약 <br>

## Triggering the Vulnarability

## Exploit primitives
7. exploit primitives <br>

### addrof

### write

## Bypass ubercage with WebAssembly
8. WebAssembly <br>

### Shellcode Smuggling

### RIP control

### Running Shellcode
9. exploit 시연 <br>

# Conclusion
10. 내가 이 글을 쓰는 목표한 바, 어떤 취약점이였는지 총정리 <br>




