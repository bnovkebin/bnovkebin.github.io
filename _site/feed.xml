<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-16T11:57:38+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Minkyun Sung</title><subtitle>Be a good Hacker</subtitle><author><name>Minkyun Sung</name><email>bnovkebin@gmail.com</email></author><entry><title type="html">CVE-2024-0517 Chrome V8 Out of Bounds Write</title><link href="http://localhost:4000/blog/CVE-2024-0517/" rel="alternate" type="text/html" title="CVE-2024-0517 Chrome V8 Out of Bounds Write" /><published>2024-08-14T00:00:00+09:00</published><updated>2024-08-14T00:00:00+09:00</updated><id>http://localhost:4000/blog/CVE-2024-0517</id><content type="html" xml:base="http://localhost:4000/blog/CVE-2024-0517/"><![CDATA[<p><br /></p>
<h1 id="introduction">Introduction</h1>
<p>In this blog, we look into a vulnerability in Chrome V8, CVE-2024-0517. This vulnerability occurs when Maglev, the JIT compiler of V8, compiles a class that has a parent class. <br />
Since I’m a beginner in the cybersecurity field and this is my first time analyzing a 1-day exploit, I had a lot of difficulty understanding it. Therefore, I’ll explain this vulnerability step by step. <br /></p>

<p><br /></p>
<h1 id="environment-configuration">Environment Configuration</h1>
<p>The version that I used is as follows:
<a href="https://chromium.googlesource.com/v8/v8.git/+/e73f620c2ef1230ddaa61551706225821a87c3b9" target="_blank">chrome v8 12.0.267.15</a> <br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="nx">install</span> <span class="nx">depot_tools</span>
<span class="nx">cd</span> <span class="o">~</span>
<span class="nx">git</span> <span class="nx">clone</span> <span class="nx">https</span><span class="p">:</span><span class="c1">//chromium.googlesource.com/chromium/tools/depot_tools.git</span>
<span class="k">export</span> <span class="nx">PATH</span><span class="o">=</span><span class="nx">$HOME</span><span class="o">/</span><span class="nx">depot_tools</span><span class="p">:</span><span class="nx">$PATH</span>
<span class="nx">echo</span> <span class="dl">'</span><span class="s1">export PATH=$HOME/depot_tools:$PATH</span><span class="dl">'</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="sr">/.zshr</span><span class="err">c
</span>
<span class="err">#</span> <span class="kd">get</span> <span class="nx">V8</span>
<span class="nx">cd</span> <span class="o">~</span>
<span class="nx">fetch</span> <span class="nx">v8</span>
<span class="nx">cd</span> <span class="nx">v8</span>
<span class="nx">git</span> <span class="nx">checkout</span> <span class="nx">e73f620c2ef1230ddaa61551706225821a87c3b9</span>
<span class="nx">gclient</span> <span class="nx">sync</span> <span class="o">-</span><span class="nx">D</span>

<span class="err">#</span> <span class="nx">build</span> <span class="nx">V8</span>
<span class="p">.</span><span class="o">/</span><span class="nx">build</span><span class="o">/</span><span class="nx">install</span><span class="o">-</span><span class="nx">build</span><span class="o">-</span><span class="nx">deps</span><span class="p">.</span><span class="nx">sh</span>
<span class="nx">gn</span> <span class="nx">gen</span> <span class="nx">out</span><span class="o">/</span><span class="nx">debug</span> <span class="o">--</span><span class="nx">args</span><span class="o">=</span><span class="dl">'</span><span class="s1">v8_no_inline=true v8_optimized_debug=false is_component_build=false v8_expose_memory_corruption_api=true</span><span class="dl">'</span>
<span class="nx">ninja</span> <span class="o">-</span><span class="nx">C</span> <span class="nx">out</span><span class="o">/</span><span class="nx">debug</span> <span class="nx">d8</span>
<span class="p">.</span><span class="o">/</span><span class="nx">tools</span><span class="o">/</span><span class="nx">dev</span><span class="o">/</span><span class="nx">gm</span><span class="p">.</span><span class="nx">py</span> <span class="nx">x64</span><span class="p">.</span><span class="nx">release</span>

<span class="err">#</span> <span class="nx">install</span> <span class="nx">gdb</span> <span class="nx">plugin</span>
<span class="nx">echo</span> <span class="dl">'</span><span class="s1">source ~/v8/tools/gdbinit</span><span class="dl">'</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="sr">/.gdbini</span><span class="err">t
</span></code></pre></div></div>

<p><br /></p>
<h1 id="preliminary-knowledge">Preliminary Knowledge</h1>
<p>In this section I’ll explain some essential preliminary knowledges needed to understand vulnerability. <br />
The first three points are very important, and the remaining content helps in understanding the entire vulnerability by being aware of the memory structure. <br /></p>

<h2 id="v8-engine">V8 engine</h2>
<center> <img src="https://www.fhinkel.rocks/assets/blog/Understanding-V8-s-Bytecode/img2.png" width="70%" height="70%" title="git_diff" /> </center>
<center> <img src="https://www.phoronix.net/image.php?id=2023&amp;image=maglev" width="70%" height="70%" title="git_diff" /> </center>
<p>V8 is composed of various components such as Ignition, Maglev. I organized some features about them.</p>
<ul>
  <li>Parser    : converts Javascript code to AST structure</li>
  <li>Ignition  : coverts AST structure to bytecode directly when code executes</li>
  <li>Sparkplug : compile and optimize bytecode without any analysis</li>
  <li>Maglev    : compile and optimize bytecode with static analysis</li>
  <li>Turbofan  : compile and optimize bytecode with dynamic analysis
The purpose of optimizing code is to ensure that subsequent executions are faster because the generated code will be reused in future calls.</li>
</ul>

<p>In the Vulnerability Exploitation Flow section, I’ll outline the process leading to the weak point.</p>

<h2 id="allocation-folding">Allocation Folding</h2>
<center> <img src="https://github.com/user-attachments/assets/d8b42923-9971-43b3-9744-079a47909f5a" title="allocation_folding" /> </center>
<p>Allocation Folding is a technique that improves performance and reduces memory overhead. It folds multiple allocation to a single one, so next allocation will be positioned with the offset by first allocation(AllocateRaw node). For example, if there are two allocations with amounts of 12 bytes and 88 bytes, Maglev folds them to one allocation with 100 bytes and the second allocation will be allocated on FirstAllocate_addr+12 (because the first requests 12 bytes).</p>

<h2 id="garbage-collection">Garbage Collection</h2>
<center> <img src="https://github.com/user-attachments/assets/0013d02f-cd2b-4474-aa0f-887ec73991b1" title="v8_heap_structure" /> </center>
<p><br /> 
Garbage Collection is a memory management process that frees object without any reference. <br />
In v8 there are two Garbage collector, minor GC and major GC. If semi-space(from-space) is filled fully, minor GC runs and frees needless object. Conversely, it is applied in the same way. And if an object survives after running twice of garbage collection, it will be moved into old space. <br /></p>

<p>I recommend to read this blog that is perfect to learn about garbage collection.
<a href="https://deepu.tech/memory-management-in-v8/" target="_blank">https://deepu.tech/memory-management-in-v8/</a></p>

<p><br /></p>
<h1 id="the-vulnerability">The Vulnerability</h1>
<p>When V8 compiles a derived class, the current_raw_allocation pointer is not initialized, leading to unintended memory allocation and potentially causing an out-of-bounds(OOB) write. <br />
The above content means that v8 calls VisitFindNonDefaultConstructorOrConstruct function. About this function I’ll explain in Vulnerability Exploitation Flow section. <br />
<br />
The Proof of Concept code is on <a href="https://github.com/bnovkebin/bnovkebin.github.io/blob/5f951163790653ce1426d0ac8427a8b170c22ca7/_posts/2024/20240814/poc.js" target="_blank">here</a>
<br />
If you run this code, it results :</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="o">~/</span><span class="n">v8</span><span class="o">/</span><span class="n">out</span><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">d8</span> <span class="o">--</span><span class="n">max</span><span class="o">-</span><span class="n">opt</span><span class="o">=</span><span class="mi">2</span> <span class="o">--</span><span class="n">allow</span><span class="o">-</span><span class="n">natives</span><span class="o">-</span><span class="n">syntax</span> <span class="o">--</span><span class="n">expose</span><span class="o">-</span><span class="n">gc</span> <span class="o">--</span><span class="n">jit</span><span class="o">-</span><span class="n">fuzzing</span> <span class="p">.</span><span class="o">/</span><span class="n">code0810</span><span class="o">/</span><span class="n">poc</span><span class="p">.</span><span class="n">js</span>

<span class="cp">#
# Fatal error in ../../src/objects/free-space-inl.h, line 75
# Check failed: !heap-&gt;deserialization_complete() || map_slot().contains_map_value(free_space_map.ptr()).
#
#
#
#FailureMessage Object: 0x7ffcb71ef328
</span><span class="o">====</span> <span class="n">C</span> <span class="n">stack</span> <span class="n">trace</span> <span class="o">===============================</span>

    <span class="p">.</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">d8</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">base</span><span class="o">::</span><span class="n">debug</span><span class="o">::</span><span class="n">StackTrace</span><span class="o">::</span><span class="n">StackTrace</span><span class="p">()</span><span class="o">+</span><span class="mh">0x1e</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x5be5e179afde</span><span class="p">]</span>
    <span class="p">.</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">d8</span><span class="p">(</span><span class="o">+</span><span class="mh">0x8c0960d</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x5be5e179560d</span><span class="p">]</span>
    <span class="p">.</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">d8</span><span class="p">(</span><span class="n">V8_Fatal</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="o">+</span><span class="mh">0x1ac</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x5be5e176b53c</span><span class="p">]</span>
    <span class="p">.</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">d8</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">FreeSpace</span><span class="o">::</span><span class="n">IsValid</span><span class="p">()</span> <span class="k">const</span><span class="o">+</span><span class="mh">0xdf</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x5be5dde6ceef</span><span class="p">]</span>
    <span class="p">.</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">d8</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">FreeSpace</span><span class="o">::</span><span class="n">next</span><span class="p">()</span> <span class="k">const</span><span class="o">+</span><span class="mh">0x1d</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x5be5dde6baad</span><span class="p">]</span>
</code></pre></div></div>
<p><br />
If you want :</p>
<ul>
  <li>Debugging =&gt; <code class="language-plaintext highlighter-rouge">./debug/d8 (option) ./code/poc.js</code></li>
  <li>Release   =&gt; <code class="language-plaintext highlighter-rouge">./x64.release/d8 (option) ./code/poc.js</code></li>
</ul>

<p>I frequently use options like :</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">--allow-natives-syntax</code> =&gt; allow using debugging symbol</li>
  <li><code class="language-plaintext highlighter-rouge">--print-maglev-graph</code> =&gt; show maglev-IR-graph that maglev has compiled</li>
</ul>

<p>(other options : <code class="language-plaintext highlighter-rouge">--max-opt=2 --expose-gc --jit-fuzzing</code>) <br /></p>

<p>If you set a breakpoint before allocate array a and after that, you can see the memory corrupt by allocation folding of array a. <br /></p>
<center> <img src="https://github.com/user-attachments/assets/574d05eb-ab29-4ed3-ac49-9cdc5b70041e" /> </center>

<h2 id="extendorreallocatecurrentrawallocation">ExtendOrReallocateCurrentRawAllocation</h2>
<p>This function represents methods to do allocation folding with <strong>“current_raw_allocation”</strong> pointer.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* src/maglev/maglev-graph-builder.cc:8520 */</span>
<span class="n">ValueNode</span><span class="o">*</span> <span class="n">MaglevGraphBuilder</span><span class="o">::</span><span class="n">ExtendOrReallocateCurrentRawAllocation</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">AllocationType</span> <span class="n">allocation_type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_raw_allocation_</span> <span class="o">||</span>
      <span class="n">current_raw_allocation_</span><span class="o">-&gt;</span><span class="n">allocation_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">allocation_type</span> <span class="o">||</span>
      <span class="o">!</span><span class="n">v8_flags</span><span class="p">.</span><span class="n">inline_new</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_raw_allocation_</span> <span class="o">=</span>
        <span class="n">AddNewNode</span><span class="o">&lt;</span><span class="n">AllocateRaw</span><span class="o">&gt;</span><span class="p">({},</span> <span class="n">allocation_type</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">current_raw_allocation_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">current_size</span> <span class="o">=</span> <span class="n">current_raw_allocation_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current_size</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">kMaxRegularHeapObjectSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">current_raw_allocation_</span> <span class="o">=</span>
               <span class="n">AddNewNode</span><span class="o">&lt;</span><span class="n">AllocateRaw</span><span class="o">&gt;</span><span class="p">({},</span> <span class="n">allocation_type</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">DCHECK_GT</span><span class="p">(</span><span class="n">current_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">previous_end</span> <span class="o">=</span> <span class="n">current_size</span><span class="p">;</span>
  <span class="n">current_raw_allocation_</span><span class="o">-&gt;</span><span class="n">extend</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">AddNewNode</span><span class="o">&lt;</span><span class="n">FoldedAllocation</span><span class="o">&gt;</span><span class="p">({</span><span class="n">current_raw_allocation_</span><span class="p">},</span> <span class="n">previous_end</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="patch">Patch</h2>
<p>To prevent this weakness, initialization of that pointer has been added to the source code.
This vulnerability was patched in version 12.0.267.16. You can verify this using <strong>“git diff”</strong>. <br /></p>

<p><code class="language-plaintext highlighter-rouge">git diff fbc4963bbff79ae2ef36821f870295f488cb497b e73f620c2ef1230ddaa61551706225821a87c3b9</code> <br /></p>

<center> <img src="https://github.com/user-attachments/assets/61e0a27d-596c-49a7-82d8-e66a0c17f294" title="git_diff" /> </center>

<p><br /></p>
<h1 id="vulnerability-exploitation-flow">Vulnerability Exploitation Flow</h1>
<p>To understand about vulnerability it will help that draw a flow. <br /><br />
The Exploitation flow is : <br />
1) Execute javascript code on V8 engine <br /> 
2) V8 convert source code to AST structure. In this part, Parser converts <strong>super();</strong> function as a call node with <strong>Super type</strong>. <br /></p>
<center> <img src="https://github.com/user-attachments/assets/a807549d-360c-491d-9350-2f5e5da0ba16" title="parser" width="40%" height="40%" /> </center>
<p><br />
3) Ignition calls <strong>“VisitCall”</strong> function when interpretes a call node. And as this node has super type, in the end Ignition makes an <strong>“FindNonDefaultConstructorOrContruct”</strong> instruction. <br /></p>
<center> <img src="https://github.com/user-attachments/assets/06f5c201-32b8-485b-aab6-26190171e23a" width="50%" height="50%" /> </center>
<p><br />
4) Since this source code is marked as “hot” code, Maglev starts to optimize and compile. Maglev puts a word “Visit” in front of instruction, and calls function in Maglev’s source code(i.e. VisitFindNonDefaultConstructorOrConstruct). <br /></p>
<center> <img src="https://github.com/user-attachments/assets/670fdaa4-b171-4c2f-827c-1d620628d594" width="45%" height="45%" /> </center>
<p><br />
5) When Maglev builds an allocation of object, there is no initialization of <strong>“current_raw_allocation”</strong> pointer. That is a root cause of this vulnerability. <br /></p>
<center> <img src="https://github.com/user-attachments/assets/81ca884a-f1cf-4436-a073-6c936075a8f8" width="60%" height="60%" /> </center>
<p><br />
6) As seen at poc code, we will make a garbage collection with “[1]=dogc();” after allocation of x array, all alived objects are moved into old space. <br />
7) Now it is turn to allocate a array. Given that the position to allocate x array has already decided with <strong>“this object + offset”</strong>, a array will be allocated in unintended address of memory (OOB Write). <br /></p>
<center> <img src="https://github.com/user-attachments/assets/c176f0c2-0fa2-4157-b634-771272130dad" width="50%" height="50%" /> </center>

<p><br /></p>
<h1 id="exploitation">Exploitation</h1>
<center> <img src="https://github.com/user-attachments/assets/61a32f48-8f3c-408c-8e2b-b26f514b7a91" /> </center>
<p>Using an OOB wirte, we could make a type confusion between two objects(x array &amp; a array) with different types. <br />
The first one has a PACKED_ELEMENTS type. And the other one has a PACKED_DOUBLE_ELEMENTS type. <br />
An array object that has PACKED_ELEMENTS stores Object or Integer. <br />
Same thing with PACKED_DOUBLE_ELEMENTS stores Float value. <br />
We know that their elements have same address in heap. Furthermore an overlapped memory is read differently. If we store an object at x[0], x array reads that memory as an object. However a array reads as a float value, that means we could leak the address of stored object.<br /></p>
<center> <img src="https://github.com/user-attachments/assets/483980ba-1f87-4d1d-886a-539d3b201ee3" /> </center>

<h2 id="triggering-the-vulnarability">Triggering the Vulnarability</h2>
<p>I used the code on exodus blog. For the reason that doesn’t trigger well the vulnerability, I tried to change number of times and size of array for garbage collection. <br />
After triggered vulnerability, memory structure in our environment is same with <a href="https://github.com/user-attachments/assets/61a32f48-8f3c-408c-8e2b-b26f514b7a91">this</a> that I uploaded on Exploitation. <br /></p>

<h2 id="exploit-primitives">Exploit primitives</h2>
<p>Now we made an OOB write in heap, using that we will implement some primitives that lead to exploit. <br />
Before analyzing the full-exploit code is <a href="https://github.com/bnovkebin/bnovkebin.github.io/blob/5f951163790653ce1426d0ac8427a8b170c22ca7/_posts/2024/20240814/exploit.js" target="_blank">here</a> <br /></p>

<p><br /></p>
<h3 id="addrof">addrof</h3>

<h3 id="write">write</h3>

<h2 id="bypass-ubercage-with-webassembly">Bypass ubercage with WebAssembly</h2>
<ol>
  <li>WebAssembly <br /></li>
</ol>

<h3 id="shellcode-smuggling">Shellcode Smuggling</h3>

<h3 id="rip-control">RIP control</h3>

<h3 id="running-shellcode">Running Shellcode</h3>
<ol>
  <li>exploit 시연 <br /></li>
</ol>

<h1 id="conclusion">Conclusion</h1>
<ol>
  <li>내가 이 글을 쓰는 목표한 바, 어떤 취약점이였는지 총정리 <br /></li>
</ol>

<h1 id="preferences">Preferences</h1>]]></content><author><name>Minkyun Sung</name><email>bnovkebin@gmail.com</email></author><category term="blog" /><category term="1-day" /><category term="chrome" /><category term="v8" /><summary type="html"><![CDATA[A deep dive about CVE-2024-0517]]></summary></entry><entry><title type="html">Second post with Front-Matter</title><link href="http://localhost:4000/blog/second_post/" rel="alternate" type="text/html" title="Second post with Front-Matter" /><published>2024-08-13T00:00:00+09:00</published><updated>2024-08-14T00:00:00+09:00</updated><id>http://localhost:4000/blog/second_post</id><content type="html" xml:base="http://localhost:4000/blog/second_post/"><![CDATA[<h1 id="1-first-index">1. first index</h1>
<p>hi~ <br />
2~~ <br /></p>
<h2 id="1-1-index">1-1. index</h2>
<h1 id="2-second-index">2. second index</h1>]]></content><author><name>Minkyun Sung</name><email>bnovkebin@gmail.com</email></author><category term="blog" /><category term="jekyll" /><category term="github" /><category term="git" /><summary type="html"><![CDATA[이 내용은 글 목록에서 보이는 설명이다.]]></summary></entry><entry><title type="html">Hello World</title><link href="http://localhost:4000/blog/first_post/" rel="alternate" type="text/html" title="Hello World" /><published>2024-08-08T00:00:00+09:00</published><updated>2024-08-08T00:00:00+09:00</updated><id>http://localhost:4000/blog/first_post</id><content type="html" xml:base="http://localhost:4000/blog/first_post/"><![CDATA[<h1 id="short-info">Short info</h1>

<p>This is my first post with github blog. <br />
I’ll share my interests in cyber security. <br />
My English skills aren’t very good, so if you find any errors, please don’t hesitate to tell me. <br /></p>

<p>The following are just some tests of Markdown usage, so you can ignore them. <br /></p>

<h1 id="목차">목차</h1>

<p><em>기울어진 텍스트</em> <br />
<strong>굵은 텍스트</strong> <br />
<strong><em>굵고 기울어진 텍스트</em></strong> <br />
<del>취소된 텍스트</del> <br />
<u>밑줄된 텍스트</u> <br />
<span style="color:yellow">노란 글씨.</span></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">f64</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Float64Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">u32</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
</code></pre></div></div>
<p>링크주소만 있는 것: <br />
<a href="https://bnovkebin.github.io">https://bnovkebin.github.io</a> <br />
링크설명과 링크주소: <br />
<a href="https://bnovkebin.github.io">bnovkebin블로그</a> <br />
동일 파일에서 문단으로 이동: <br />
<a href="#목차">목차로 이동</a> <br /></p>

<p><img src="https://bnovkebin.github.io/assets/images/mypuppy.png" width="100px" height="100px" title="Mypuppy" /> <br /></p>

<p><img src="https://bnovkebin.github.io/assets/images/mypuppy.png" alt="git_diff" /></p>]]></content><author><name>Minkyun Sung</name><email>bnovkebin@gmail.com</email></author><category term="blog" /><summary type="html"><![CDATA[Short info]]></summary></entry></feed>